import { MeshDetection, FacePose, Coord3D, PosePoint, PoseDetection } from '@geenee/bodytracking';
export { MeshDetection, PosePoint } from '@geenee/bodytracking';
import { ProcParams, Processor, Size, ImageInput, Engine, EngineParams, VideoSource } from '@geenee/armature';

/** Parameters of [[FaceProcessor]] */
interface FaceParams extends ProcParams {
    /**
     * Evaluate transformation aligning reference face 3D model
     * with the measured one. Applying this transformation one can
     * align 3D object with the current pose (translation+rotation)
     * of the head. If the model's initial position is aligned with
     * the reference face, relative transformation will be preserved
     */
    transform?: boolean;
    /**
     * Evaluate metric 3D points - points within 3D space
     * of perspective camera located at the space origin
     * and pointed in the negative direction of the Z-axis.
     * These points can be used to apply texture face mask.
     */
    metric?: boolean;
    backproj?: boolean;
    /**
     * Evaluate with higher precision for lips, eyes and irises.
     * When enabled computation is slower, but contours of lips
     * are much more accurate and eye/iris detection is enabled.
     */
    highp?: boolean;
}
/** Results of [[FaceProcessor]] */
interface FaceResult {
    /**
     * Basic face detection [[MeshDetection | results]].
     * 2D pixel face landmarks - points in the screen coordinate space.
     * X and Y coordinates are normalized screen coordinates (scaled by
     * width and height of the input image), while the Z coordinate is
     * depth within orthographic projection space. These points can be
     * used for 2D face filters or when using orthographic projection.
     * Additionally, bounding box [x0, y0, x1, y1] and reliability score.
     */
    mesh?: MeshDetection;
    /**
     * Face pose - transformation matrix (translation+rotation+scale)
     * aligning reference face 3D model with the measured 3D face mesh.
     * Applying this transformation one can align 3D object with the
     * detected face. If the model's initial position is aligned with
     * the reference face, relative transformation will be preserved.
     */
    transform?: FacePose;
    /**
     * 3D metric points - points within 3D space of perspective camera
     * located at the space origin and pointed in the negative direction
     * of the Z-axis. These points can be used to apply texture face mask.
     */
    metric?: Coord3D[];
    backproj?: Coord3D[];
}
/**
 * Face mesh processor
 *
 * Face mesh processor estimates 3D face landmarks, it detects and
 * tracks face mesh providing smooth, stable and accurate results.
 * Processor evaluates 2D pixel and 3D metric points as well as face
 * pose (translation+rotation+scale) aligning reference face model.
 * 2D pixel face landmarks - points in the screen coordinate space.
 * X and Y coordinates are normalized screen coordinates (scaled by
 * width and height of the input image), while the Z coordinate is
 * depth within orthographic projection space. These points can be
 * used for 2D face filters or when using orthographic projection.
 * 3D metric points - points within 3D space of perspective camera
 * located at the space origin and pointed in the negative direction
 * of the Z-axis. These points can be used to apply texture face mask.
 * 3D and 2D points are perfectly aligned, projections of 3D points
 * coincide with 2D pixel coordinates within the perspective camera.
 * Face pose - transformation matrix (translation+rotation+scale)
 * aligning reference face 3D model with the measured 3D face mesh.
 * Applying this transformation one can align 3D object with the
 * detected face. If the model's initial position is aligned with
 * the reference face, relative transformation will be preserved.
 */
declare class FaceProcessor extends Processor<FaceResult, FaceParams> {
    /** Face mesh tracker (computation engine) */
    private faceTracker;
    /** View angle of perspective camera along smallest side */
    readonly cameraAngleBase: number;
    /**
     * Initialize processor
     *
     * Prepares all resources required for face mesh tracking.
     *
     * @param params - Processor parameters
     * @param size - Resolution of input video
     * @param ratio - Aspect ration of input video
     * @returns Status of initialization
     * @override
     */
    init(params: FaceParams, size?: Size, ratio?: number): Promise<boolean>;
    /**
     * Reset processor
     *
     * Resets all processing instances to the initial state.
     *
     * @override
     */
    reset(): void;
    /**
     * Dispose processor object
     *
     * Releases resources and instances allocated by processor.
     * Processor object cannot be used after calling dispose().
     *
     * @override
     */
    dispose(): void;
    /**
     * Process the image
     *
     * Face mesh processor detects and tracks faces.
     *
     * @param input - Image
     * @returns Face mesh or undefined
     * @override
     */
    process(input: ImageInput, timestamp?: number): Promise<FaceResult | undefined>;
    /**
     * Set resolution of the input video
     *
     * Defines view angle according to resolution and aspect ratio.
     * Face mesh processor fixes FoV for more accurate estimation.
     *
     * @param size - Resolution of input video
     * @param ratio - Aspect ration of input video
     * @override
     */
    setupVideo(size: Size, ratio?: number): void;
}
/**
 * Face engine
 *
 * Specialization of [[Engine]] for [[FaceProcessor]].
 * Straightforward wrapper to simplifying source code.
 * Instead of `new Engine(FaceProcessor, ...)` you can
 * use simpler `const engine = new FaceEngine(...})`.
 */
declare class FaceEngine extends Engine<FaceResult, FaceParams, FaceProcessor> {
    /**
     * Constructor
     *
     * @param engineParams - Parameters of the engine
     */
    constructor(engineParams?: EngineParams, Source?: new () => VideoSource);
}

declare type PointName = typeof PointNames[number];
declare type PosePoints = {
    [key in PointName]: PosePoint;
};
declare type PoseDebug = PoseDetection["debug"];
/** Pose detection */
interface Pose {
    /**
     * List of pose [[PosePoint | keypoints]].
     *
     * 2D pixel coordinate - point in the screen coordinate space.
     * XY coordinates are normalized screen coordinates (scaled by
     * image width and height), while the Z coordinate is depth
     * in orthographic projection space, it has the same scale as X.
     * 3D metric coordinate - point within 3D space of perspective
     * camera located at the space origin and pointed in the negative
     * direction of the Z-axis. 3D & 2D points are perfectly aligned.
     */
    points: PosePoints;
    /** Reliability score, number between 0 and 1 */
    score: number;
    debug: PoseDebug;
}
/** Results of [[PoseProcessor]] */
interface PoseResult {
    /** Array of detected [[Pose | poses]] */
    poses: Pose[];
}
/**
 * Pose processor
 *
 * Pose processor estimates 33 2D and 3D pose keypoints, it locates
 * the person / pose region-of-interest (ROI) and predicts the pose
 * keypoints providing smooth, stable and accurate pose estimation.
 * 2D pixel pose keypoints - points in the screen coordinate space.
 * X and Y coordinates are normalized screen coordinates (scaled by
 * width and height of the input image), while the Z coordinate is
 * depth within orthographic projection space, it has the same scale
 * as X coordinate (normalized by image width) and 0 is at the center
 * of hips. These points can be used for 2D pose overlays or when
 * using orthographic projection. Estimation of Z coordinate is not
 * very accurate and we recommend to use only XY for 2D effects.
 * 3D metric points - points within 3D space of perspective camera
 * located at the space origin and pointed in the negative direction
 * of the Z-axis. These points can be used for 3D avatar overlays or
 * virtual try-on. Rigged and skinned models can be rendered on top
 * of the pose aligning skeleton/armature joints with 3D keypoints.
 * 3D and 2D points are perfectly aligned, projections of 3D points
 * coincide with 2D pixel coordinates within the perspective camera.
 */
declare class PoseProcessor extends Processor<PoseResult> {
    /** Pose tracker (computation engine) */
    private poseTracker;
    /** View angle of perspective camera along smallest side */
    readonly cameraAngleBase: number;
    /** Constructor */
    constructor();
    /**
     * Initialize processor
     *
     * Prepares all resources required for pose estimation.
     *
     * @param params - Processor parameters
     * @param size - Resolution of input video
     * @param ratio - Aspect ration of input video
     * @returns Status of initialization
     * @override
     */
    init(params: ProcParams, size?: Size, ratio?: number): Promise<boolean>;
    /**
     * Reset processor
     *
     * Resets all processing instances to the initial state.
     *
     * @override
     */
    reset(): void;
    /**
     * Dispose processor object
     *
     * Releases resources and instances allocated by processor.
     * Processor object cannot be used after calling dispose().
     *
     * @override
     */
    dispose(): void;
    /**
     * Process the image
     *
     * Pose processor detects pose and predicts pose keypoints.
     *
     * @param input - Image
     * @returns Pose estimation or undefined
     * @override
     */
    process(input: ImageInput, timestamp?: number): Promise<PoseResult | undefined>;
    /**
     * Set resolution of the input video
     *
     * Defines view angle according to resolution and aspect ratio.
     * Pose processor fixes FoV for more accurate pose alignment.
     *
     * @param size - Resolution of input video
     * @param ratio - Aspect ration of input video
     * @override
     */
    setupVideo(size: Size, ratio?: number): void;
}
/**
 * Pose engine
 *
 * Specialization of [[Engine]] for [[PoseProcessor]].
 * Straightforward wrapper to simplifying source code.
 * Instead of `new Engine(PoseProcessor, ...)` you can
 * use simpler `const engine = new PoseEngine(...})`.
 */
declare class PoseEngine extends Engine<PoseResult, ProcParams, PoseProcessor> {
    /**
     * Constructor
     *
     * @param engineParams - Parameters of the engine
     */
    constructor(engineParams?: EngineParams, Source?: new () => VideoSource);
}
declare const PointNames: readonly ["nose", "eyeInnerL", "eyeL", "eyeOutterL", "eyeInnerR", "eyeR", "eyeOutterR", "earL", "earR", "mouthL", "mouthR", "shoulderL", "shoulderR", "elbowL", "elbowR", "wristL", "wristR", "pinkyL", "pinkyR", "indexL", "indexR", "thumbL", "thumbR", "hipL", "hipR", "kneeL", "kneeR", "ankleL", "ankleR", "heelL", "heelR", "footIndexL", "footIndexR"];

export { FaceEngine, FaceParams, FaceProcessor, FaceResult, Pose, PoseEngine, PosePoints, PoseProcessor, PoseResult };
